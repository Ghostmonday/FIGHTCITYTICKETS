# Backend Platform (FastAPI)

Purpose: how the FastAPI service boots, wires middleware, and exposes routers so it can be rebuilt faithfully.

## Responsibilities
- Initialize FastAPI app with lifespan hook for DB readiness logging.
- Wire middleware: request IDs, metrics, rate limiting, CORS, error handling.
- Register routers for all feature areas.
- Configure logging and Sentry.

## Key files
- `backend/src/app.py` — main app, middleware, router inclusion, CORS.
- `backend/src/middleware/` — request ID, errors, rate limit, resilience.
- `backend/src/routes/` — routers (tickets, statement, appeals, checkout, webhooks, status, health, admin, places, telemetry).
- `backend/src/logging_config.py`, `backend/src/sentry_config.py` — logging + Sentry bootstrap.

## Boot sequence
1. Load settings (`config.py`).
2. Configure structured logging (JSON by default) and optional file log when JSON disabled.
3. Init Sentry if DSN present.
4. Lifespan startup logs environment + URLs; pings DB (`get_db_service().health_check()`).
5. Middleware stack:
   - `RequestIDMiddleware` injects/propagates `X-Request-ID`.
   - Metrics middleware increments request/error counters (health module helpers).
   - Rate limit: global `slowapi` limiter; exception handler `_rate_limit_exceeded_handler`.
   - CORS: origins from `settings.cors_origin_list()`, all standard methods/headers.
6. Routers mounted with prefixes defined inside route modules.
7. Limiter instance shared to modules (checkout, webhooks, admin, tickets, statement).

## Error handling
- Custom `APIError` with `ErrorCode` enum and unified error response shape.
- `unhandled_exception_handler` fallback.
- Rate-limit errors mapped to structured JSON.

## Conventions
- All routes depend on DB service via dependency injection or service layer, not raw sessions.
- JSON responses with standardized error payload from middleware/errors module.
- Request IDs logged and should be echoed to clients for support correlation.

## Rebuild checklist
- Use FastAPI 0.115+, Python 3.12.
- Add middleware in the order above; ensure limiter instance shared after router import.
- Preserve lifespan behavior (startup/shutdown logs; DB dispose on shutdown).
- Keep descriptions on app object for autogenerated docs parity.
